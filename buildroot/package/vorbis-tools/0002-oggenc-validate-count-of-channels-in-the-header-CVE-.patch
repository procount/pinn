From 3bbabc06c4b35c84f6747ed850213161aca568c7 Mon Sep 17 00:00:00 2001
From: Petter Reinholdtsen <pere@debian.org>
Date: Tue, 22 Sep 2015 15:14:06 +0200
Subject: [PATCH] oggenc: validate count of channels in the header
 (CVE-2014-9638 & CVE-2014-9639)

Author: Kamil Dudka <kdudka@redhat.com>
Origin: http://lists.xiph.org/pipermail/vorbis-dev/2015-February/020423.html
Bug: https://trac.xiph.org/ticket/2136
Bug: https://trac.xiph.org/ticket/2137
Bug-Debian: https://bugs.debian.org/776086
Forwarded: not-needed
Reviewed-By: Petter Reinholdtsen <pere@hungry.com>
Last-Update: 2015-09-22
Signed-off-by: Peter Korsgaard <peter@korsgaard.com>
---
 oggenc/audio.c | 18 ++++++++++++++++--
 1 file changed, 16 insertions(+), 2 deletions(-)

diff --git a/oggenc/audio.c b/oggenc/audio.c
index 4921fb9..535a704 100644
--- a/oggenc/audio.c
+++ b/oggenc/audio.c
@@ -13,6 +13,7 @@
 #include <config.h>
 #endif
 
+#include <limits.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -251,6 +252,7 @@ int aiff_open(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen)
     aiff_fmt format;
     aifffile *aiff = malloc(sizeof(aifffile));
     int i;
+    long channels;
 
     if(buf[11]=='C')
         aifc=1;
@@ -277,11 +279,16 @@ int aiff_open(FILE *in, oe_enc_opt *opt, unsigned char *buf, int buflen)
         return 0;
     }
 
-    format.channels = READ_U16_BE(buffer);
+    format.channels = channels = READ_U16_BE(buffer);
     format.totalframes = READ_U32_BE(buffer+2);
     format.samplesize = READ_U16_BE(buffer+6);
     format.rate = (int)read_IEEE80(buffer+8);
 
+    if(channels <= 0L || SHRT_MAX < channels)
+    {
+        fprintf(stderr, _("Warning: Unsupported count of channels in AIFF header\n"));
+        return 0;
+    }
     aiff->bigendian = 1;
 
     if(aifc)
@@ -416,6 +423,7 @@ int wav_open(FILE *in, oe_enc_opt *opt, unsigned char *oldbuf, int buflen)
     wav_fmt format;
     wavfile *wav = malloc(sizeof(wavfile));
     int i;
+    long channels;
 
     /* Ok. At this point, we know we have a WAV file. Now we have to detect
      * whether we support the subtype, and we have to find the actual data
@@ -453,12 +461,18 @@ int wav_open(FILE *in, oe_enc_opt *opt, unsigned char *oldbuf, int buflen)
     }
 
     format.format =      READ_U16_LE(buf);
-    format.channels =    READ_U16_LE(buf+2);
+    format.channels = channels = READ_U16_LE(buf+2);
     format.samplerate =  READ_U32_LE(buf+4);
     format.bytespersec = READ_U32_LE(buf+8);
     format.align =       READ_U16_LE(buf+12);
     format.samplesize =  READ_U16_LE(buf+14);
 
+    if(channels <= 0L || SHRT_MAX < channels)
+    {
+        fprintf(stderr, _("Warning: Unsupported count of channels in WAV header\n"));
+        return 0;
+    }
+
     if(format.format == -2) /* WAVE_FORMAT_EXTENSIBLE */
     {
       if(len<40)
-- 
2.20.1

